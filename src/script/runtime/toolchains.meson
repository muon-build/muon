# SPDX-FileCopyrightText: Stone Tickle <lattis@mochiro.moe>
# SPDX-License-Identifier: GPL-3.0-only

toolchain = import('toolchain')
fs = import('fs')

################################################################################
# static linkers
################################################################################

# https://pubs.opengroup.org/onlinepubs/9699919799/
toolchain.register_archiver(
    'ar-posix',
    exe: 'ar',
    handlers: {
        'base': ['csr'],
        'input_output': func(_c compiler, input str, output str) -> list[str]
            return [output, input]
        endfunc,
        'needs_wipe': true,
    },
)

toolchain.register_archiver(
    'ar-gnu',
    inherit: 'ar-posix',
    detect: func(out str) -> int
        return 'Free Software Foundation' in out ? 100 : 0
    endfunc,
    handlers: {
        'version': ['--version'],
        'base': ['csrD'],
    },
)

toolchain.register_archiver(
    'lib',
    exe: 'lib',
    detect: func(out str) -> int
        return 'Microsoft' in out ? 100 : 0
    endfunc,
    handlers: {
        'always': func(c compiler) -> list[str]
            m = c.machine().address_bits() == 64 ? '64' : '86'
            return ['/NOLOGO', f'/MACHINE:X@m@']
        endfunc,
        'input_output': func(_c compiler, input str, output str) -> list[str]
            return [f'/OUT:@output@', input]
        endfunc,
        'version': ['/?'],
    },
)

toolchain.register_archiver(
    'ar-tcc',
    inherit: 'ar-posix',
    exe: 'tcc',
    detect: func(out str) -> int
        return 'tcc' in out ? 100 : 0
    endfunc,
    handlers: {
        'version': ['--version'],
        'always': ['-ar'],
        'base': ['csr'],
        'needs_wipe': true,
    },
)

################################################################################
# linkers
################################################################################

toolchain.register_linker(
    'ld-posix',
    exe: 'ld',
    handlers: {
        'version': ['-v'],
        'input_output': func(_c compiler, input str, output str) -> list[str]
            return [output, input]
        endfunc,
        'lib': func(_c compiler, lib str) -> list[str]
            return ['-l', lib]
        endfunc,
        'shared': ['-shared'],
    },
)

toolchain.register_linker(
    'ld',
    inherit: 'ld-posix',
    detect: func(out str) -> int
        return 'GNU' in out ? 100 : 0
    endfunc,
    handlers: {
        'allow_shlib_undefined': ['--allow-shlib-undefined'],
        'as_needed': ['--as-needed'],
        'coverage': ['--coverage'],
        'def': func(_c compiler, s1 str) -> list[str]
            return [s1]
        endfunc,
        'enable_lto': ['-flto'],
        'end_group': ['--end-group'],
        'export_dynamic': func(c compiler) -> list[str]
            if c.machine().system() == 'windows'
                return ['-export-all-symbols']
            else
                return ['-export-dynamic']
            endif
        endfunc,
        'fatal_warnings': ['--fatal-warnings'],
        'implib': func(_c compiler, s1 str) -> list[str]
            return ['--out-implib,' + s1]
        endfunc,
        'implib_suffix': ['.dll.a'],
        'no_undefined': ['--no-undefined'],
        'pgo': func(_c compiler, stage str) -> list[str]
            if stage == 'generate'
                return ['-fprofile-generate']
            elif stage == 'use'
                return ['-fprofile-correction', '-fprofile-use']
            endif
        endfunc,
        'rpath': func(c compiler, s1 str) -> list[str]
            if c.machine().system() == 'windows'
                return []
            else
                return ['-rpath,' + s1]
            endif
        endfunc,
        'sanitize': func(_c compiler, s1 str) -> list[str]
            return ['-fsanitize=' + s1]
        endfunc,
        'shared_module': ['-shared'],
        'soname': func(_c compiler, s1 str) -> list[str]
            return ['-soname', s1]
        endfunc,
        'start_group': ['--start-group'],
        'whole_archive': func(_c compiler, s1 str) -> list[str]
            return ['--whole-archive', s1, '--no-whole-archive']
        endfunc,
    },
)

toolchain.register_linker(
    'lld',
    inherit: 'ld',
    exe: 'lld',
)

toolchain.register_linker(
    'lld-win',
    inherit: 'lld',
    handlers: {
        'allow_shlib_undefined': [],
        'export_dynamic': [],
        'soname': [],
    },
)

toolchain.register_linker(
    'lld-apple',
    inherit: 'ld-posix',
    exe: 'lld',
    detect: func(out str) -> int
        return 'Apple' in out ? 100 : 0
    endfunc,
    handlers: {
        'allow_shlib_undefined': ['-undefined', 'dynamic_lookup'],
        'enable_lto': ['-flto'],
        'rpath': func(_c compiler, s1 str) -> list[str]
            return ['-rpath,' + s1]
        endfunc,
        'sanitize': func(_c compiler, s1 str) -> list[str]
            return ['-fsanitize=' + s1]
        endfunc,
        'shared_module': ['-bundle'],
        'whole_archive': func(_c compiler, s1 str) -> list[str]
            return ['-force_load', s1]
        endfunc,
    },
)

toolchain.register_linker(
    'link',
    exe: 'link',
    handlers: {
        'always': func(c compiler) -> list[str]
            m = c.machine().address_bits() == 64 ? '64' : '86'
            return ['/NOLOGO', f'/MACHINE:X@m@']
        endfunc,
        'check_ignored_option': func(_c compiler, s str) -> bool
            # Check for link command line warning LNK4044: unrecognized option
            return 'LNK4044' in s
        endfunc,
        'debug': ['/DEBUG'],
        'def': func(_c compiler, s str) -> list[str]
            return [f'/DEF:@s@']
        endfunc,
        'implib': func(_c compiler, s str) -> list[str]
            return [f'/IMPLIB:@s@']
        endfunc,
        'input_output': func(_c compiler, input str, output str) -> list[str]
            return [f'/OUT:@output@', input]
        endfunc,
        'lib': func(_c compiler, s str) -> list[str]
            return [s]
        endfunc,
        'shared': ['/DLL'],
        'shared_module': ['/DLL'],
        'version': ['/?'],
        'whole_archive': func(_c compiler, s str) -> list[str]
            return [f'/WHOLEARCHIVE:@s@']
        endfunc,
    },
)

toolchain.register_linker(
    'lld-link',
    inherit: 'link',
    exe: 'lld-link',
    handlers: {
        'lib': toolchain.handler('linker', 'ld-posix', 'lib'),
        'fuse_ld': ['-fuse-ld=lld-link'],
        'check_ignored_option': func(c compiler, s str) -> bool
            return (
                toolchain.handler('linker', 'link', 'check_ignored_option')(c, s)
                or 'ignoring unknown argument' in s
            )
        endfunc,
    },
)

toolchain.register_linker(
    'ld-tcc',
    inherit: 'ld-posix',
    exe: 'tcc',
    handlers: {
        'def': func(_c compiler, s1 str) -> list[str]
            # Apparently the tcc linker needs -L. to find any .def files.
            return ['-L.', '-l' + s1]
        endfunc,
        'export_dynamic': ['-rdynamic'],
        'implib': [],
        'implib_suffix': ['.def'],
        'input_output': func(_c compiler, input str, output str) -> list[str]
            return [output, input]
        endfunc,
        'lib': func(_c compiler, lib str) -> list[str]
            return ['-l', lib]
        endfunc,
        'shared': ['-shared'],
        'shared_module': ['-shared'],
        'soname': func(_c compiler, s1 str) -> list[str]
            return ['-soname', s1]
        endfunc,
        'version': ['-v'],
        'whole_archive': func(_c compiler, s1 str) -> list[str]
            return ['--whole-archive', s1, '--no-whole-archive']
        endfunc,
    },
)

################################################################################
# compilers
################################################################################

toolchain.register_compiler(
    'posix',
    exe: {'c': 'cc', 'objc': 'cc', 'cpp': 'c++', 'objcpp': 'c++'},
    linker: 'ld-posix',
    archiver: 'ar-posix',
    handlers: {
        'version': ['--version'],
        'do_linker_passthrough': true,
        'linker_passthrough': func(_c compiler, args list[str]) -> list[str]
            len = args.length()
            if len == 0
                return args
            elif len == 1
                if args[0] in ['-shared', '-bundle', '-dynamiclib', '-rdynamic'] or args[0].startswith('-fuse-ld=')
                    return args
                endif

                return ['-Wl,' + args[0]]
            elif len == 2
                if args[0] == '-l'
                    # "-Wl,-l,dl" errors out on some compilers - use "-ldl" form
                    return ['-l' + args[1]]
                endif

                return ['-Wl,' + args[0] + ',' + args[1]]
            elif len == 3
                return ['-Wl,' + args[0], args[1], '-Wl,' + args[2]]
            else
                error('unhandled linker_passthrough @0@'.format(args))
            endif
        endfunc,
        'compile_only': ['-c'],
        'preprocess_only': ['-E'],
        'output': func(_c compiler, s str) -> list[str]
            return ['-o', s]
        endfunc,
        'optimization': func(_c compiler, lvl str) -> list[str]
            if lvl == '0'
                return ['-O0']
            elif lvl in ['1', '2', '3']
                return ['-O1']
            else
                return []
            endif
        endfunc,
        'debug': ['-g'],
        'include': func(_c compiler, s str) -> list[str]
            return ['-I', s]
        endfunc,
        'include_system': func(_c compiler, s str) -> list[str]
            return ['-I', s]
        endfunc,
        'object_ext': ['.o'],
        'define': func(_c compiler, s str) -> list[str]
            return ['-D', s]
        endfunc,
        'pic': func(c compiler) -> list[str]
            return c.machine().system() == 'windows' ? [] : ['-fPIC']
        endfunc,
        'force_language': func(_c compiler, s str) -> list[str]
            return ['-x', s]
        endfunc,
        'werror': ['-Werror'],
    },
)

toolchain.register_compiler(
    'gcc',
    exe: {'c': 'gcc', 'objc': 'gcc', 'cpp': 'g++', 'objcpp': 'g++'},
    linker: 'ld',
    archiver: 'ar-gnu',
    inherit: 'posix',
    detect: func(out str) -> int
        return 'Free Software Foundation' in out ? 100 : 0
    endfunc,
    handlers: {
        'argument_syntax': ['gcc'],
        'color_output': func(c compiler, s str) -> list[str]
            if c.version().version_compare('<4.9.0')
                return []
            endif

            return ['-fdiagnostics-color=' + s]
        endfunc,
        'coverage': ['--coverage'],
        'deps': func(_c compiler, s1 str, s2 str) -> list[str]
            return ['-MD', '-MQ', s1, '-MF', s2]
        endfunc,
        'deps_type': ['gcc'],
        'enable_lto': ['-flto'],
        'include_dirafter': func(_c compiler, s1 str) -> list[str]
            return ['-idirafter', s1]
        endfunc,
        'include_pch': func(_c compiler, s1 str) -> list[str]
            name = fs.name(s1)
            assert(name.endswith('.gch'))
            return ['-I', fs.parent(s1), '-include', fs.name(s1).substring(0, -4)]
        endfunc,
        'include_system': func(_c compiler, s1 str) -> list[str]
            return ['-isystem', s1]
        endfunc,
        'optimization': func(_c compiler, lvl str) -> list[str]
            if lvl == 'none'
                return []
            else
                return ['-O' + lvl]
            endif
        endfunc,
        'pch_ext': ['.gch'],
        'permissive': ['-fpermissive'],
        'pgo': func(_c compiler, stage str) -> list[str]
            if stage == 'generate'
                return ['-fprofile-generate']
            elif stage == 'use'
                return ['-fprofile-correction', '-fprofile-use']
            endif
        endfunc,
        'pie': ['-fPIE'],
        'preprocess_only': ['-E', '-P'],
        'sanitize': func(_c compiler, s1 str) -> list[str]
            return ['-fsanitize=' + s1]
        endfunc,
        'set_std': func(_c compiler, s1 str) -> list[str]
            return ['-std=' + s1]
        endfunc,
        'visibility': func(_c compiler, type str) -> list[str]
            if type == 'default'
                return ['-fvisibility=default']
            elif type == 'internal'
                return ['-fvisibility=internal']
            elif type == 'protected'
                return ['-fvisibility=protected']
            elif type == 'inlineshidden'
                return ['-fvisibility=hidden', '-fvisibility-inlines-hidden']
            elif type == 'hidden'
                return ['-fvisibility=hidden']
            endif
        endfunc,
        'warn_everything': [], # TODO
        'warning_lvl': func(_c compiler, lvl str) -> list[str]
            args = []
            if lvl in ['1', '2', '3']
                args += '-Wall'
            endif

            if lvl in ['2', '3']
                args += '-Wextra'
            endif

            if lvl in ['3']
                args += '-pedantic'
            endif
            return args
        endfunc,
        'winvalid_pch': ['-Winvalid-pch'],
        'print_search_dirs': ['-print-search-dirs'],
        'dumpmachine': ['-dumpmachine'],
    },
)

toolchain.register_compiler(
    'clang',
    inherit: 'gcc',
    exe: {'c': 'clang', 'objc': 'clang', 'cpp': 'clang++', 'objcpp': 'clang++'},
    linker: func(c compiler) -> str
        m = c.machine()
        t = c.target_triple()
        if m.system() == 'windows'
            if t.env == 'gnu'
                return 'lld-win'
            else
                return 'lld-link'
            endif
        elif m.system() == 'darwin' or 'Apple' in c.version_raw()
            return 'lld-apple'
        else
            return 'lld'
        endif
    endfunc,
    archiver: 'ar-posix',
    detect: func(out str) -> int
        return 'clang' in out.to_lower() ? 50 : 0
    endfunc,
    handlers: {
        'can_compile_llvm_ir': true,
        'color_output': func(_c compiler, s str) -> list[str]
            return ['-fdiagnostics-color=' + s]
        endfunc,
        'emit_pch': ['-Xclang', '-emit-pch'],
        'include_pch': func(_c compiler, s1 str) -> list[str]
            return ['-include-pch', s1]
        endfunc,
        'pch_ext': ['.pch'],
        'warn_everything': ['-Weverything'],
    },
)

toolchain.register_compiler(
    'clang-llvm-ir',
    exe: {'llvm_ir': 'clang'},
    handlers: {
        'compile_only': toolchain.handler('compiler', 'posix', 'compile_only'),
        'output': toolchain.handler('compiler', 'posix', 'output'),
        'object_ext': toolchain.handler('compiler', 'posix', 'object_ext'),
    },
)

toolchain.register_compiler(
    'msvc',
    exe: {'c': 'cl', 'cpp': 'cl'},
    linker: 'link',
    archiver: 'lib',
    detect: func(out str) -> int
        return 'Microsoft' in out ? 100 : 0
    endfunc,
    handlers: {
        'always': ['/nologo'],
        'argument_syntax': ['msvc'],
        'check_ignored_option': func(_c compiler, s str) -> bool
            # Check for msvc command line warning D9002 : ignoring unknown option
            return 'D9002' in s
        endfunc,
        'compile_only': ['/c'],
        'crt': func(_c compiler, s str, debug bool) -> list[str]
            if s == 'from_buildtype'
                return debug ? ['/MDd'] : ['/MD']
            elif s == 'static_from_buildtype'
                return debug ? ['/MTd'] : ['/MT']
            else
                return [s]
            endif
        endfunc,
        'debug': ['/Zi'],
        'debugfile': func(_c compiler, s str) -> list[str]
            return [f'/Fd@s@.pdb']
        endfunc,
        'define': func(_c compiler, s str) -> list[str]
            return ['/D', s]
        endfunc,
        'deps': ['/showIncludes'],
        'deps_type': ['msvc'],
        'include': func(_c compiler, s str) -> list[str]
            return ['/I', s]
        endfunc,
        'linker_delimiter': ['/link'],
        'object_ext': ['.obj'],
        'optimization': func(_c compiler, lvl str) -> list[str]
            if lvl == '0'
                return ['/Od']
            elif lvl == '1'
                return ['/O1']
            elif lvl == '2'
                return ['/O2']
            elif lvl == '3'
                return ['/O2', '/Gw']
            elif lvl == 's'
                return ['/O1', '/Gw']
            else
                return []
            endif
        endfunc,
        'output': func(_c compiler, s str) -> list[str]
            if s.to_lower().endswith('.exe')
                return [f'/Fe@s@']
            else
                return [f'/Fo@s@']
            endif
        endfunc,
        'preprocess_only': ['/EP'],
        'sanitize': func(_c compiler, s1 str) -> list[str]
            return ['-fsanitize=' + s1]
        endfunc,
        'set_std': func(_c compiler, s1 str) -> list[str]
            return [f'/std:@s1@']
        endfunc,
        'std_unsupported': func(_c compiler, s1 str) -> bool
            return s1 not in [
                'c++14',
                'c++17',
                'c++20',
                'c++latest',
                'c11',
                'c17',
                'clatest',
            ]
        endfunc,
        'version': ['/?'],
        'warn_everything': ['/Wall'],
        'warning_lvl': func(_c compiler, lvl str) -> list[str]
            # meson uses nothing instead of /W0, but it's the same warning level
            # see: https://mesonbuild.com/Builtin-options.html#details-for-warning_level
            if lvl == '1'
                return ['/W2']
            elif lvl == '2'
                return ['/W3']
            elif lvl in ['3', 'everything']
                return ['/W4']
            else
                return []
            endif
        endfunc,
        'werror': ['/WX'],
    },
)

toolchain.register_compiler(
    'tcc',
    inherit: 'posix',
    exe: {'c': 'tcc'},
    linker: 'ld-tcc',
    archiver: 'ar-tcc',
    detect: func(out str) -> int
        return 'tcc' in out ? 100 : 0
    endfunc,
    handlers: {
        'warn_everything': ['-Wall'],
    },
)

toolchain.register_compiler(
    'nasm',
    exe: {'nasm': 'nasm'},
    detect: func(out str) -> int
        return 'NASM' in out ? 100 : 1
    endfunc,
    linker: 'ld-posix',
    archiver: 'ar-posix',
    handlers: {
        'version': ['--version'],
        'always': func(c compiler) -> list[str]
            m = c.machine()
            address_bits = m.address_bits()
            if m.system() == 'windows'
                plat = 'win'
                def = f'WIN@address_bits@'
            elif m.system() == 'darwin'
                plat = 'macho'
                def = 'MACHO'
            else
                plat = 'elf'
                def = 'ELF'
            endif

            res = [f'-f@plat@@address_bits@', f'-D@def@']
            if address_bits == 64
                res += '-D__x86_64__'
            endif
            return res
        endfunc,
        'debug': toolchain.handler('compiler', 'posix', 'debug'),
        'define': toolchain.handler('compiler', 'posix', 'define'),
        'include': toolchain.handler('compiler', 'posix', 'include'),
        'include_system': toolchain.handler('compiler', 'posix', 'include_system'),
        'object_ext': toolchain.handler('compiler', 'posix', 'object_ext'),
        'optimization': toolchain.handler('compiler', 'posix', 'optimization'),
        'output': toolchain.handler('compiler', 'posix', 'output'),
    },
)

toolchain.register_compiler(
    'yasm',
    exe: {'nasm': 'yasm'},
    inherit: 'nasm',
    detect: func(out str) -> int
        return 'yasm' in out ? 100 : 0
    endfunc,
)
