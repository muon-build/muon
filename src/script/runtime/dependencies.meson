# SPDX-FileCopyrightText: Stone Tickle <lattis@mochiro.moe>
# SPDX-License-Identifier: GPL-3.0-only

fs = import('fs')
pkgconfig = import('pkgconfig')

################################################################################
# Helpers
################################################################################

func clike_compiler(native bool) -> compiler
    foreach candidate : ['c', 'cpp', 'objc', 'objcpp']
        if meson.has_compiler(candidate, native: native)
            return meson.get_compiler(candidate, native: native)
        endif
    endforeach

    error('No c-like compiler available.')
endfunc

func not_found() -> dep
    return dependency('', required: false)
endfunc

func config_tool(tool external_program, args list[str]) -> str
    return run_command([tool] + args, check: true).stdout()
endfunc

## Parses an array of compiler arguments and sorts them into groups suitable
## for passing to declare_dependency()
## This function merges the result into an existing dict.
func config_tool_parse(
    ## The config tool
    tool external_program,
    ## A list of arguments to run the config tool with
    args list[str],
    ## A dict to merge the results with
    parse_into dict[any],
    ## A compiler to use when resolving libraries
    compiler compiler:,
    ## Forwarded from the dependency() call
    static bool:,
    ## Where to store unmatched flags, e.g. `compile_args` or `link_args`
    flags_key str:,
) -> dict[any]
    output = config_tool(tool, args)

    split = output.shell_split(shell: 'posix')

    parsed = pkgconfig.parse_fragments(split, compiler: compiler, static: static, flags_key: flags_key)

    foreach k, v : parsed
        if k not in parse_into
            parse_into[k] = []
        endif

        parse_into[k] += v
    endforeach

    return parse_into
endfunc

################################################################################
# Handlers
################################################################################

meson.register_dependency_handler(
    'intl',
    builtin: func(native bool:, _ glob[any]:) -> dep
        code = '#include <libintl.h>"n"nint main() {"n    gettext("Hello world");"n}'

        return clike_compiler(native).links(code) ? declare_dependency() : not_found()
    endfunc,
    system: func(static bool:, native bool:, _ glob[any]:) -> dep
        return clike_compiler(native).find_library(
            'intl',
            has_headers: ['libintl.h'],
            static: static,
            required: false,
        )
    endfunc,
)

meson.register_dependency_handler(
    'iconv',
    builtin: func(native bool:, _ glob[any]:) -> dep
        code = '#include <iconv.h>"n"nint main() {"n    iconv_open("","");"n}'

        return clike_compiler(native).links(code) ? declare_dependency() : not_found()
    endfunc,
    system: func(static bool:, native bool:, _ glob[any]:) -> dep
        return clike_compiler(native).find_library(
            'iconv',
            has_headers: ['iconv.h'],
            static: static,
            required: false,
        )
    endfunc,
)

meson.register_dependency_handler(
    'zlib',
    order: ['pkg-config', 'system'],
    system: func(static bool:, native bool:, _ glob[any]:) -> dep
        cc = clike_compiler(native)

        if cc.get_internal_id() == 'clang-apple'
            dep = declare_dependency(
                link_args: '-lz',
            )
        else
            dep = cc.find_library(
                'z',
                has_headers: ['zlib.h'],
                static: static,
                required: false,
            )
        endif

        if not dep.found()
            return dep
        endif

        return declare_dependency(
            dependencies: dep,
            version: cc.get_define('ZLIB_VERSION', prefix: '#include <zlib.h>').strip('"'),
        )
    endfunc,
)

meson.register_dependency_handler(
    'objfw',
    config_tool: func(modules list[str]:, native bool:, static bool:, _ glob[any]:) -> dep
        objfwconfig = find_program('objfw-config', required: false)

        if not objfwconfig.found()
            return not_found()
        endif

        modules_args = []
        if not is_null(modules)
            foreach module : modules
                modules_args += '--package'
                modules_args += module
            endforeach
        endif

        cc = clike_compiler(native)

        version = config_tool(objfwconfig, ['--version']).strip()

        parsed = {}
        foreach key, flags : {
            'compile_args': ['--cppflags', '--objcflags'],
            'link_args': ['--ldflags', '--libs'],
        }
            parsed = config_tool_parse(
                objfwconfig,
                flags + modules_args,
                parsed,
                flags_key: key,
                compiler: cc,
                static: static,
            )
        endforeach

        return declare_dependency(version: version, kwargs: parsed)
    endfunc,
)

meson.register_dependency_handler(
    'gtest',
    system: func(main bool: false, native bool:, _ glob[any]:) -> dep
        cc = clike_compiler(native)
        deps = [dependency('threads')]

        gtest_lib = cc.find_library('gtest', required: false)
        gtest_main_lib = cc.find_library('gtest_main', required: false)

        if gtest_lib.found() and (not main or gtest_main_lib.found())
            deps += gtest_lib
            if gtest_main_lib.found()
                deps += gtest_main_lib
            endif

            return declare_dependency(dependencies: deps)
        endif

        foreach s : ['/usr/src/gtest/src', '/usr/src/googletest/googletest/src']
            if fs.is_dir(s)
                sources = files(s / 'gtest-all.cc')
                if main
                    sources += files(s / 'gtest_main.cc')
                endif

                return declare_dependency(
                    sources: sources,
                    include_directories: [
                        s / '..',
                        s / '../include',
                    ],
                )
            endif
        endforeach

        return not_found()
    endfunc,
    pkgconfig: func(main bool: false, kwargs glob[any]:) -> dep
        name = 'gtest'
        if main
            name += '_main'
        endif

        return dependency(name, method: 'pkg-config', kwargs: kwargs)
    endfunc,
)

meson.register_dependency_handler(
    'dl',
    builtin: func(native bool:, _ glob[any]:) -> dep
        cc = clike_compiler(native)
        if cc.has_function('dlopen', prefix: '#include <dlfcn.h>')
            return declare_dependency()
        endif

        return not_found()
    endfunc,
    system: func(native bool:, _ glob[any]:) -> dep
        cc = clike_compiler(native)
        if cc.has_header('dlfcn.h')
            return cc.find_library('dl', required: false)
        endif

        return not_found()
    endfunc,
)

meson.register_dependency_handler(
    'pcap',
    order: ['config-tool', 'pkg-config'],
    config_tool: func(native bool:, static bool:, _ glob[any]:) -> dep
        pcapconfig = find_program('pcap-config', native: native, required: false)

        if not pcapconfig.found()
            return not_found()
        endif

        cc = clike_compiler(native)

        version = config_tool(pcapconfig, ['--version'])

        parsed = {}
        foreach key, flags : {'compile_args': ['--cflags'], 'link_args': ['--libs']}
            parsed = config_tool_parse(
                pcapconfig,
                flags,
                parsed,
                flags_key: key,
                compiler: cc,
                static: static,
            )
        endforeach

        return declare_dependency(version: version, kwargs: parsed)
    endfunc,
    pkgconfig: func(native bool:, kwargs glob[any]:) -> dep
        return dependency('libpcap', method: 'pkg-config', native: native, kwargs: kwargs)
    endfunc,
)
