# SPDX-FileCopyrightText: Stone Tickle <lattis@mochiro.moe>
# SPDX-License-Identifier: GPL-3.0-only

fs = import('fs')

func banner(msg str)
    print(
        f'--------------------------------\n@msg@\n--------------------------------\n',
    )
endfunc

muon_private = '.muon'

muon = argv[1]
ninja = argv[2]
source = argv[3]
build = argv[4]
skip_exit_code = argv[5]
skip_analyze = argv[6] == '1'
git_clean = argv[7] == '1'
failing = argv[8] == '1'
skip_uninstall = argv[9] == '1'

extra_setup_opts = argv.slice(10)

test_json = source / 'test.json'
if fs.is_file(test_json)
    json = import('json')
    test_json = json.parse(fs.read(test_json))
else
    test_json = {}
endif

if fs.is_dir(build)
    fs.rmdir(build, recursive: true, force: true)
endif

if git_clean
    warning('running git clean on @0@'.format(source))
    run_command('git', '-C', source, 'clean', '-xdf', check: true)
endif

fs.mkdir(build / muon_private, make_parents: true)

if not skip_analyze
    banner('analyze')
    analyze_result = run_command(muon, '-vC', source, 'analyze')

    if analyze_result.returncode() != 0
        print(analyze_result.stdout())
        print(analyze_result.stderr())
        exit(analyze_result.returncode())
    endif
endif

banner('setup')

if ninja == 'USE_MUON'
    ninja = [muon, 'samu']
else
    ninja = [ninja]
endif

setup_result = run_command(
    muon,
    '-vC', source,
    'setup',
    '-Dprefix=/usr',
    '-Denv.NINJA=' + repr(ninja),
    extra_setup_opts,
    build,
)

if setup_result.returncode() != 0
    print(setup_result.stdout())
    print(setup_result.stderr())

    if 'MESON_SKIP_TEST' in setup_result.stdout() or failing
        exit(skip_exit_code.to_int())
    else
        exit(setup_result.returncode())
    endif
endif

if failing
    print('test was marked failing but did not fail')
    exit(99)
endif

banner('build')

run_command(ninja, '-C', build, check: true, capture: false)

banner('test')

run_command(muon, '-C', build, 'test', '-a', check: true, capture: false)

banner('install')

destdir = 'destdir'
assert(not fs.exists(build / destdir), 'destdir must not exist')
run_command(
    muon,
    '-C', build,
    'install',
    env: {'DESTDIR': destdir},
    check: true,
    capture: false,
)

func check_install()
    banner('check install')

    is_windows = host_machine.system() == 'windows'

    destdir_contents = {}
    if fs.exists(build / destdir)
        foreach path : fs.glob(build / destdir / '**')
            if fs.is_file(path)
                destdir_contents[path] = false
            endif
        endforeach
    endif

    ok = true

    foreach f : test_json.get('installed', [])
        path = build / destdir / f.file
        check = fs.is_file

        if 'platform' in f
            if f.platform.startswith('!')
                if host_machine.system() == p(f.platform.substring(1))
                    continue
                endif
            else
                if host_machine.system() != f.platform
                    continue
                endif
            endif
        endif

        if f.type == 'file'
            # nothing
        elif f.type == 'dir'
            check = fs.is_dir
        elif f.type == 'exe'
            if is_windows
                path += '.exe'
            endif
        elif f.type == 'python_file'
            path = path.replace('@PYTHON_PURELIB@', 'python_purelib')
        elif f.type in 'expr'
            if '?lib' in path
                path = path.replace('?lib', 'lib')
                if is_windows
                    path = path.replace('usr/lib', 'usr/bin')
                endif
            endif

            if path.endswith('?so')
                path = path.substring(0, -3)

                if host_machine.system() == 'darwin'
                    path += '.dylib'
                elif is_windows
                    path += '.dll'

                    name = fs.name(path)
                    if name.startswith('lib')
                        path = fs.parent(path) / name.substring(3)
                    endif
                else
                    path += '.so'
                endif
            endif
        elif f.type in ['implibempty', 'pdb', 'implib']
            # unsupported
            continue
        else
            error('unhandled installed type @0@'.format(f.type))
        endif

        if check(path)
            if f.type != 'dir'
                destdir_contents[path] = true
            endif
        else
            warning('path @0@ of type @1@ was not installed'.format(path, f.type))
            ok = false
        endif
    endforeach

    foreach path, accounted_for : destdir_contents
        if not accounted_for
            warning(
                'path @0@ exists in destdir but was not mentioned in test.json'.format(path),
            )
            ok = false
        endif
    endforeach

    assert(ok)
endfunc
check_install()

if not skip_uninstall
    banner('uninstall')

    run_command(
        muon,
        '-C', build,
        'install',
        '-Ud', destdir,
        check: true,
        capture: false,
    )

    assert(
        not fs.exists(build / destdir),
        'destdir should have been fully uninstalled',
    )
endif
